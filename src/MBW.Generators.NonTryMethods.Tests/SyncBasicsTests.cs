using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using MBW.Generators.NonTryMethods.Tests.Helpers;
using MBW.Generators.Tests.Common;
using Microsoft.CodeAnalysis;
using Xunit;

public sealed class SyncBasicsTests
{
    [Fact]
    public void DefaultExceptionType_InvalidOperationException_OnFalseReturn()
    {
        (string? output, IReadOnlyList<Diagnostic> diags) =
            TestsHelper.RunHelper("""
                                  using MBW.Generators.NonTryMethods.Attributes;

                                  [GenerateNonTryMethod]
                                  public partial class Exc
                                  {
                                      public bool TryCompute(int a, int b, out int sum)
                                      {
                                          sum = a + b;
                                          return a >= 0 && b >= 0;
                                      }
                                  }
                                  """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>

                           partial class Exc
                           {
                               public int Compute(int a, int b)
                               {
                                   if (TryCompute(a, b, out var sum)) return sum;
                                   throw new InvalidOperationException();
                               }
                           }
                           """, output);
    }

    [Fact]
    public void Preserves_Defaults_Ref_In_Params_And_Order()
    {
        (string? output, IReadOnlyList<Diagnostic> diags) =
            TestsHelper.RunHelper("""
                                  using MBW.Generators.NonTryMethods.Attributes;

                                  [GenerateNonTryMethod]
                                  public partial class DefaultsRefInParams
                                  {
                                      public bool TryJoin(in int count, ref int seed, string sep = ",", params string[] items)
                                      {
                                          seed = seed + count;
                                          if (items is null || items.Length == 0) { items = new[] { "X" }; }
                                          return (items.Length > 0, out var _).Item1; // just to use the 'out'-shape idea
                                      }

                                      // Real candidate
                                      public bool TryMake(in int count, ref int seed, string sep = ",", out string result, params string[] items)
                                      {
                                          seed = seed + count;
                                          result = string.Join(sep, items);
                                          return items.Length > 0;
                                      }
                                  }
                                  """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>

                           partial class DefaultsRefInParams
                           {
                               public string Make(in int count, ref int seed, string sep = ",", params string[] items)
                               {
                                   if (TryMake(in count, ref seed, sep, out var result, items)) return result;
                                   throw new InvalidOperationException();
                               }
                           }
                           """, output);
    }

    [Fact]
    public void ExtensionMethod_PreservesThisParameter()
    {
        (string? output, IReadOnlyList<Diagnostic> diags) =
            TestsHelper.RunHelper("""
                                  using System;
                                  using MBW.Generators.NonTryMethods.Attributes;

                                  public static class StrExt
                                  {
                                      [GenerateNonTryMethod]
                                      public static bool TryTakeUntil(this string s, char c, out string part)
                                      {
                                          int idx = s?.IndexOf(c) ?? -1;
                                          if (idx < 0) { part = default!; return false; }
                                          part = s.Substring(0, idx);
                                          return true;
                                      }
                                  }
                                  """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>

                           static partial class StrExt
                           {
                               public static string TakeUntil(this string s, char c)
                               {
                                   if (TryTakeUntil(s, c, out var part)) return part;
                                   throw new InvalidOperationException();
                               }
                           }
                           """, output);
    }

    [Fact]
    public void GenericMethod_WithConstraints_IsPreserved()
    {
        (string? output, IReadOnlyList<Diagnostic> diags) =
            TestsHelper.RunHelper("""
                                  using System;
                                  using MBW.Generators.NonTryMethods.Attributes;

                                  public interface IParsable<T>
                                  {
                                      static abstract bool TryParse(string s, out T value);
                                  }

                                  [GenerateNonTryMethod]
                                  public partial class Parser
                                  {
                                      public bool TryParse<T>(string s, out T value) where T : struct, IParsable<T>
                                      {
                                          return IParsable<T>.TryParse(s, out value);
                                      }
                                  }
                                  """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>

                           partial class Parser
                           {
                               public T Parse<T>(string s) where T : struct, IParsable<T>
                               {
                                   if (TryParse<T>(s, out var value)) return value;
                                   throw new InvalidOperationException();
                               }
                           }
                           """, output);
    }

    [Fact]
    public void Interface_DefaultImplementation_Works()
    {
        (string? output, IReadOnlyList<Diagnostic> diags) =
            TestsHelper.RunHelper("""
                                  using MBW.Generators.NonTryMethods.Attributes;

                                  [GenerateNonTryMethod]
                                  public partial interface IRepo
                                  {
                                      bool TryGet(out string? v)
                                      {
                                          v = "ok";
                                          return true;
                                      }
                                  }
                                  """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>

                           partial interface IRepo
                           {
                               public string? Get()
                               {
                                   if (TryGet(out var v)) return v;
                                   throw new InvalidOperationException();
                               }
                           }
                           """, output);
    }
}
