using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MBW.Generators.Common;
using MBW.Generators.Common.Helpers;
using MBW.Generators.OverloadGenerator.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;

namespace MBW.Generators.OverloadGenerator;

internal static class OverloadCodeGen
{
    internal static string? Generate(TypeSpec spec, ref List<Diagnostic>? diagnostics)
    {
        var type = spec.Type;
        var ns = type.ContainingNamespace;

        (string typeOpeners, string typeClosers, string methodIndent) = BuildTypeBlocks(type, ns);
        StringBuilder methodsText = new StringBuilder();

        foreach (var method in spec.Methods)
        {
            foreach (Rule rule in method.Rules)
            {
                string? generated = GenerateMethodSource(method.Method, rule, methodIndent, ref diagnostics);
                if (generated is not null)
                    methodsText.Append(generated);
            }
        }

        if (methodsText.Length == 0)
            return null;

        return $"// <auto-generated/>\n" +
               (ns.IsGlobalNamespace ? string.Empty : $"namespace {ns.ToDisplayString()}\n{{\n") +
               typeOpeners + methodsText + typeClosers +
               (ns.IsGlobalNamespace ? string.Empty : "}");
    }

    private static string? GenerateMethodSource(IMethodSymbol method, Rule rule, string indent,
        ref List<Diagnostic>? diagnostics)
    {
        int index = Array.FindIndex(method.Parameters.ToArray(), p => p.Name == rule.Parameter);
        if (index < 0)
        {
            diagnostics ??= new();
            diagnostics.Add(Diagnostic.Create(Diagnostics.MissingParameter, method.Locations[0], method.Name,
                rule.Parameter));
            return null;
        }

        TransformRule? trRule = rule as TransformRule;
        DefaultRule? drRule = rule as DefaultRule;

        if (trRule is not null)
        {
            if (trRule.Accept is null)
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidAcceptType, method.Locations[0],
                    trRule.Parameter, "null"));
                return null;
            }

            var acceptInvalidReason = GetParameterTypeInvalidReason(trRule.Accept);
            if (acceptInvalidReason is not null)
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidAcceptType, method.Locations[0],
                    trRule.Parameter, acceptInvalidReason));
                return null;
            }

            if (string.IsNullOrWhiteSpace(trRule.Transform) || !trRule.Transform.Contains("{value}"))
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.MissingValueToken, method.Locations[0],
                    trRule.Parameter));
                return null;
            }

            var exprCheck = trRule.Transform.Replace("{value}", "value");
            var exprSyntax = SyntaxFactory.ParseExpression(exprCheck);
            if (exprSyntax.ContainsDiagnostics)
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidTransformExpression, method.Locations[0],
                    trRule.Parameter, trRule.Transform));
                return null;
            }
        }
        else if (drRule is not null)
        {
            if (string.IsNullOrWhiteSpace(drRule.Expression))
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.MissingDefaultExpression, method.Locations[0],
                    drRule.Parameter));
                return null;
            }

            if (method.IsExtensionMethod && method.Parameters.Length > 0 &&
                method.Parameters[0].Name == drRule.Parameter)
            {
                diagnostics ??= new();
                diagnostics.Add(Diagnostic.Create(Diagnostics.CannotRemoveThis, method.Locations[0],
                    method.Name, drRule.Parameter));
                return null;
            }
        }

        List<string> parameters = new();
        List<string> arguments = new();
        List<(ITypeSymbol type, RefKind kind, bool isParams)> signature = new();

        foreach (var p in method.Parameters)
        {
            if (drRule != null && p.Name == drRule.Parameter)
            {
                arguments.Add(drRule.Expression);
                continue;
            }

            bool isFirstParam = p.Ordinal == 0;
            bool emitThis = method.IsExtensionMethod && isFirstParam;

            string modifier = p.RefKind switch
            {
                RefKind.Ref => "ref ",
                RefKind.Out => "out ",
                RefKind.In => "in ",
                _ => string.Empty
            };

            string paramsPrefix = p.IsParams ? "params " : string.Empty;

            string typeName;
            string arg;

            if (trRule != null && p.Name == trRule.Parameter)
            {
                typeName = trRule.Accept!.ToDisplayString(DisplayFormats.NullableQualifiedFormat);
                arg = modifier + trRule.Transform.Replace("{value}", p.Name);
                signature.Add((trRule.Accept!, p.RefKind, p.IsParams));
            }
            else
            {
                typeName = p.Type.ToDisplayString(DisplayFormats.NullableQualifiedFormat);
                arg = modifier + p.Name;
                signature.Add((p.Type, p.RefKind, p.IsParams));
            }

            string thisPrefix = emitThis ? "this " : string.Empty;

            parameters.Add($"{thisPrefix}{paramsPrefix}{modifier}{typeName} {p.Name}{GetDefaultValue(p)}");
            arguments.Add(arg);
        }

        if (SignatureExists(method.ContainingType, method, signature))
        {
            diagnostics ??= new();
            diagnostics.Add(Diagnostic.Create(Diagnostics.SignatureCollision, method.Locations[0], method.Name));
            return null;
        }

        string accessibility = GetAccessibility(method.DeclaredAccessibility);
        string modifiers = method.IsStatic ? " static" : string.Empty;
        string returnType = method.ReturnType.ToDisplayString(DisplayFormats.NullableQualifiedFormat);
        string methodName = method.Name;
        string typeParams = method.IsGenericMethod
            ? "<" + string.Join(", ", method.TypeParameters.Select(tp => tp.Name)) + ">"
            : string.Empty;
        string constraints = BuildConstraints(method);

        string paramList = string.Join(", ", parameters);
        string argList = string.Join(", ", arguments);

        string constraintsText = string.IsNullOrWhiteSpace(constraints)
            ? string.Empty
            : $"\n{indent}    {constraints}";

        return $"""
{indent}{accessibility}{modifiers} {returnType} {methodName}{typeParams}({paramList}){constraintsText}
{indent}    => {methodName}{typeParams}({argList});

""";
    }

    private static (string openers, string closers, string methodIndent) BuildTypeBlocks(
        INamedTypeSymbol type,
        INamespaceSymbol ns)
    {
        List<INamedTypeSymbol> types = GetTypeChain(type);
        int nsIndent = ns.IsGlobalNamespace ? 0 : 1;

        StringBuilder open = new();
        for (int i = 0; i < types.Count; i++)
        {
            INamedTypeSymbol t = types[i];
            string indent = new string(' ', 4 * (nsIndent + i));
            string decl = GetTypeDeclarationLine(t);

            open.Append(indent).Append(decl).Append('\n');
            open.Append(indent).Append("{").Append('\n');
        }

        StringBuilder close = new();
        for (int i = types.Count - 1; i >= 0; i--)
        {
            string indent = new string(' ', 4 * (nsIndent + i));
            close.Append(indent).Append("}").Append('\n');
        }

        string methodIndent = new string(' ', 4 * (nsIndent + types.Count));
        return (open.ToString(), close.ToString(), methodIndent);
    }

    private static string GetTypeDeclarationLine(INamedTypeSymbol t)
    {
        var mods = new List<string>();
        if (t.IsStatic)
        {
            mods.Add("static");
        }
        else
        {
            if (t.IsAbstract) mods.Add("abstract");
            if (t.IsSealed && t.TypeKind == TypeKind.Class && !t.IsStatic) mods.Add("sealed");
            if (t.IsValueType && !t.IsRefLikeType && t.IsReadOnly) mods.Add("readonly");
        }

        string kind;
        if (t.TypeKind == TypeKind.Struct)
        {
            if (t.IsRefLikeType)
                kind = "ref struct";
            else if (t.IsRecord)
                kind = "record struct";
            else
                kind = "struct";
        }
        else if (t.TypeKind == TypeKind.Class)
        {
            kind = t.IsRecord ? "record" : "class";
        }
        else if (t.TypeKind == TypeKind.Interface)
        {
            kind = "interface";
        }
        else
        {
            kind = "class";
        }

        string typeParams = t.TypeParameters.Length > 0
            ? "<" + string.Join(", ", t.TypeParameters.Select(tp => tp.Name)) + ">"
            : string.Empty;

        var head = string.Join(" ", mods.Concat(new[] { "partial", kind })).Trim();
        return $"{head} {t.Name}{typeParams}";
    }

    private static List<INamedTypeSymbol> GetTypeChain(INamedTypeSymbol type)
    {
        Stack<INamedTypeSymbol> stack = new();
        INamedTypeSymbol? current = type;
        while (current is not null)
        {
            stack.Push(current);
            current = current.ContainingType;
        }

        return stack.ToList();
    }

    private static bool SignatureExists(INamedTypeSymbol type, IMethodSymbol original,
        List<(ITypeSymbol type, RefKind kind, bool isParams)> signature)
    {
        foreach (IMethodSymbol member in type.GetMembers(original.Name).OfType<IMethodSymbol>())
        {
            if (SymbolEqualityComparer.Default.Equals(member, original))
                continue;
            if (member.Parameters.Length != signature.Count)
                continue;

            bool match = true;
            for (int i = 0; i < signature.Count; i++)
            {
                IParameterSymbol mp = member.Parameters[i];
                (ITypeSymbol type, RefKind kind, bool isParams) np = signature[i];
                if (mp.RefKind != np.kind || mp.IsParams != np.isParams ||
                    !SymbolEqualityComparer.Default.Equals(mp.Type, np.type))
                {
                    match = false;
                    break;
                }
            }

            if (match)
                return true;
        }

        return false;
    }

    private static string GetAccessibility(Accessibility accessibility) => accessibility switch
    {
        Accessibility.Public => "public",
        Accessibility.Private => "private",
        Accessibility.Internal => "internal",
        Accessibility.Protected => "protected",
        Accessibility.ProtectedAndInternal => "private protected",
        Accessibility.ProtectedOrInternal => "protected internal",
        _ => "public"
    };

    private static string BuildConstraints(IMethodSymbol method)
    {
        if (!method.IsGenericMethod)
            return string.Empty;

        List<string> clauses = new();
        foreach (ITypeParameterSymbol tp in method.TypeParameters)
        {
            List<string> c = new();
            if (tp.HasReferenceTypeConstraint)
                c.Add("class");
            if (tp.HasValueTypeConstraint)
                c.Add("struct");
            if (tp.HasUnmanagedTypeConstraint)
                c.Add("unmanaged");
            if (tp.HasNotNullConstraint)
                c.Add("notnull");
            c.AddRange(tp.ConstraintTypes.Select(t => t.ToDisplayString(DisplayFormats.NullableQualifiedFormat)));
            if (tp.HasConstructorConstraint)
                c.Add("new()");
            if (c.Count > 0)
                clauses.Add($"where {tp.Name} : {string.Join(", ", c)}");
        }

        return string.Join(" ", clauses);
    }

    private static string GetDefaultValue(IParameterSymbol p)
    {
        if (!p.HasExplicitDefaultValue)
            return string.Empty;

        return " = " + GenerationHelpers.ToCSharpLiteralExpression(p.ExplicitDefaultValue);
    }

    private static string? GetParameterTypeInvalidReason(ITypeSymbol type)
    {
        if (type.SpecialType == SpecialType.System_Void)
            return "void";

        if (type.TypeKind == TypeKind.Error)
            return "unresolved type";

        if (type is INamedTypeSymbol nt)
        {
            if (nt.IsUnboundGenericType)
                return "unbound generic type";

            if (nt.IsStatic && nt.TypeKind == TypeKind.Class)
                return "static class";
        }

        return null;
    }
}
