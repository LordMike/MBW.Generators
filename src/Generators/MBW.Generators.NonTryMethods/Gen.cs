using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Linq;
using MBW.Generators.NonTryMethods.Attributes;
using MBW.Generators.NonTryMethods.Emitter;         // <-- new emitter models & generator
using MBW.Generators.NonTryMethods.GenerationModels;
using MBW.Generators.NonTryMethods.Helpers;
using MBW.Generators.NonTryMethods.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace MBW.Generators.NonTryMethods;

internal static class Gen
{
    public static CompilationUnitSyntax BuildCompilationUnit(
        ref List<Diagnostic>? diagnostics,
        TypeSpec spec,
        bool needsTasks)
    {
        var headerTrivia = SyntaxFactory.TriviaList(
            SyntaxFactory.Comment("// <auto-generated/>"),
            SyntaxFactory.CarriageReturnLineFeed,
            SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), isActive: true)),
            SyntaxFactory.CarriageReturnLineFeed
        );

        // Usings
        var usings = new List<UsingDirectiveSyntax> { SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System")) };
        if (needsTasks) usings.Add(SyntaxFactory.UsingDirective(SyntaxFactory.ParseName("System.Threading.Tasks")));

        // Build member containers
        var typePlan = DetermineTypeStrategy(spec);
        var (partials, extensions) = EmitAllMembers(ref diagnostics, spec, typePlan);

        var baseTypeDecl = BuildTargetTypeDeclaration(spec.Type, partials);
        MemberDeclarationSyntax rootMember;

        if (extensions.Count == 0)
        {
            rootMember = baseTypeDecl;
        }
        else if (partials.Count == 0)
        {
            rootMember = BuildExtensionsContainer(spec.Type, extensions);
        }
        else
        {
            // Primary file emits the partial type. Driver can emit extensions in a separate hint if desired.
            rootMember = baseTypeDecl;
        }

        // Namespace
        var cu = SyntaxFactory.CompilationUnit().WithUsings(SyntaxFactory.List(usings));
        var ns = spec.Type.ContainingNamespace;
        if (ns is { IsGlobalNamespace: false })
        {
            var nsDecl = SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.ParseName(ns.ToDisplayString()))
                .WithMembers(SyntaxFactory.SingletonList(rootMember));
            cu = cu.WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(nsDecl));
        }
        else
        {
            cu = cu.WithMembers(SyntaxFactory.SingletonList(rootMember));
        }

        return cu.WithLeadingTrivia(headerTrivia);
    }

    public static TypeEmissionPlan DetermineTypeStrategy(TypeSpec spec)
    {
        var opts = spec.Options;
        var type = spec.Type;
        bool isInterface = type.TypeKind == TypeKind.Interface;

        var strategy = opts.MethodsGenerationStrategy == MethodsGenerationStrategy.Auto
            ? MethodsGenerationStrategy.PartialType
            : opts.MethodsGenerationStrategy;

        return new TypeEmissionPlan(strategy, isInterface: isInterface);
    }

    // ──────────────────────────────────────────────────────────────────────────
    // Emission: map each eligible source method -> NonTryCodeGenerator models -> MethodDeclarationSyntax

    private static (List<MethodDeclarationSyntax> partials, List<MethodDeclarationSyntax> extensions)
        EmitAllMembers(ref List<Diagnostic>? diagnostics, TypeSpec spec, TypeEmissionPlan typePlan)
    {
        var partials = new List<MethodDeclarationSyntax>();
        var extensions = new List<MethodDeclarationSyntax>();

        foreach (var ms in spec.Methods)
        {
            if (!TryEmitOne(ref diagnostics, spec, typePlan, ms, out var methodDecl, out var kind))
                continue;

            if (kind == EmissionKind.Extension) extensions.Add(methodDecl);
            else partials.Add(methodDecl);
        }

        return (partials, extensions);
    }

    private static bool TryEmitOne(
        ref List<Diagnostic>? diagnostics,
        TypeSpec typeSpec,
        TypeEmissionPlan typePlan,
        MethodSpec methodSpec,
        out MethodDeclarationSyntax methodDecl,
        out EmissionKind emittedKind)
    {
        methodDecl = default!;
        emittedKind = default;

        var method = methodSpec.Method;
        var ks = typeSpec.Symbols;

        // Choose attribute (warn on multiple matches)
        var attrib = PickAttribute(ref diagnostics, typeSpec, methodSpec);

        // Classify supported shape
        var cls = ClassifyMethodShape(method, typeSpec.Options, ks);
        if (cls.Shape == MethodShape.NotEligible)
        {
            var looksSync = method.ReturnType.SpecialType == SpecialType.System_Boolean ||
                            method.Parameters.Any(p => p.RefKind == RefKind.Out);
            diagnostics ??= [];
            diagnostics.Add(Diagnostic.Create(
                looksSync ? Diagnostics.NotEligibleSync : Diagnostics.NotEligibleAsyncShape,
                method.Locations.FirstOrDefault(),
                method.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat), attrib.MethodNamePattern,
                typeSpec.Options.AsyncCandidateStrategy));
            return false;
        }

        // Determine emission kind
        emittedKind = typePlan.Strategy == MethodsGenerationStrategy.Extensions
            ? EmissionKind.Extension
            : typePlan.IsInterface ? EmissionKind.InterfaceDefault
            : EmissionKind.Partial;

        if (emittedKind == EmissionKind.Extension && method.IsStatic)
        {
            diagnostics ??= [];
            diagnostics.Add(Diagnostic.Create(
                Diagnostics.UnableToGenerateExtensionMethodForStaticMethod,
                method.Locations.FirstOrDefault(),
                method.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat), method.Name, typeSpec.Type.Name));
            return false;
        }

        // Compute generated name
        string newName = ComputeGeneratedName(method.Name, attrib);

        // Shape-specific: async vs sync, valueTask etc
        bool isAsync = cls.Shape == MethodShape.AsyncTuple;
        bool isValueTask = cls.IsValueTask;

        // Return type + unwrap rules
        var opts = typeSpec.Options;
        bool unwrapNullable;
        ITypeSymbol generatedReturn;

        if (!isAsync)
        {
            var outP = cls.OutParam!;
            unwrapNullable = ShouldUnwrapNullable(outP.Type, opts.ReturnGenerationStrategy);

            var payload = AdjustForReturnStrategy(outP.Type, opts.ReturnGenerationStrategy);
            generatedReturn = payload;
        }
        else
        {
            Debug.Assert(ks is { ValueTaskOfT: not null, TaskOfT: not null });
            unwrapNullable = ShouldUnwrapNullable(cls.PayloadType!, opts.ReturnGenerationStrategy);

            var payload = AdjustForReturnStrategy(cls.PayloadType!, opts.ReturnGenerationStrategy);
            INamedTypeSymbol wrapper = isValueTask ? ks.ValueTaskOfT! : ks.TaskOfT!;
            generatedReturn = wrapper.Construct(payload);
        }

        // Build emitter EmissionPlan (receiver ref/in for structs)
        var receiverRefKind = NeedsRefReceiver(method) ? RefKind.Ref
                             : NeedsInReceiver(method) ? RefKind.In
                             : RefKind.None;

        var emissionPlan = new EmissionPlan(
            Kind: emittedKind,
            SelfName: null, // let emitter pick via GenerationHelpers.FindUnusedParamName
            ExtensionReceiverType: emittedKind == EmissionKind.Extension ? method.ContainingType : null,
            ReceiverRefKind: receiverRefKind
        );

        // Generated parameter models (non-out for sync case)
        var genParams = isAsync
            ? method.Parameters.Select(p => new ParameterModel(
                Name: p.Name, Type: p.Type, RefKind: p.RefKind,
                IsParams: p.IsParams,
                HasDefault: p.HasExplicitDefaultValue,
                DefaultValue: p.HasExplicitDefaultValue ? p.ExplicitDefaultValue : null))
            : method.Parameters.Where(p => p.RefKind != RefKind.Out).Select(p => new ParameterModel(
                Name: p.Name, Type: p.Type, RefKind: p.RefKind,
                IsParams: p.IsParams,
                HasDefault: p.HasExplicitDefaultValue,
                DefaultValue: p.HasExplicitDefaultValue ? p.ExplicitDefaultValue : null));

        // Out-parameter position mapped into generated parameter list for sync case
        int? outIndex = null;
        if (!isAsync)
        {
            var original = method.Parameters;
            var originalOutPos = Array.FindIndex(original.ToArray(), p => p.RefKind == RefKind.Out);
            if (originalOutPos >= 0)
            {
                // Count non-out params before the out position
                var beforeNonOut = 0;
                for (int i = 0; i < originalOutPos; i++)
                    if (original[i].RefKind != RefKind.Out) beforeNonOut++;
                outIndex = beforeNonOut;
            }
        }

        // Source descriptor
        var tryShape = isAsync ? TryShape.AsyncTupleTask : TryShape.SyncOut;
        var src = new TrySourceDescriptor(
            Name: method.Name,
            IsStatic: method.IsStatic,
            ContainingType: method.IsStatic ? method.ContainingType : null,
            Shape: tryShape,
            OutParamIndex: outIndex,
            UnwrapNullableValue: unwrapNullable,
            TypeArguments: ImmutableArray<ITypeSymbol>.Empty // prefer inference
        );

        // Generic parameters
        var methodTps = method.TypeParameters;
        var liftedTps = CollectLiftedReceiverTypeParams(method.ContainingType);

        // Build NonTry model
        var model = new NonTryModel(
            GeneratedName: newName,
            GeneratedReturnType: generatedReturn,
            Parameters: genParams.ToImmutableArray(),
            Source: src,
            ExceptionType: attrib.ExceptionType,
            MethodTypeParams: methodTps,
            LiftedReceiverTypeParams: liftedTps
        );

        // Accessibility + staticness behavior for partial/interface
        var accessibility = method.DeclaredAccessibility;
        bool isStaticInPartial = emittedKind == EmissionKind.Partial ? method.IsStatic : false;

        // Emit
        methodDecl = NonTryCodeGenerator.Emit(model, emissionPlan, accessibility, isStaticInPartial);
        return true;
    }

    private static GenerateNonTryMethodAttributeInfoWithValidPattern PickAttribute(
        ref List<Diagnostic>? diagnostics, TypeSpec typeSpec, MethodSpec methodSpec)
    {
        var method = methodSpec.Method;
        var matches = methodSpec.ApplicableAttributes.Where(a => a.Pattern.IsMatch(method.Name)).ToArray();
        if (matches.Length == 0)
            throw new InvalidOperationException("Expected method to have 1+ matching attributes");
        if (matches.Length >= 2)
        {
            diagnostics ??= [];
            diagnostics.Add(Diagnostic.Create(
                Diagnostics.MultiplePatternsMatchMethod,
                method.Locations.FirstOrDefault(),
                method.ToDisplayString(SymbolDisplayFormat.MinimallyQualifiedFormat), method.Name,
                typeSpec.Type.Name,
                string.Join(", ", matches.Select(s => $"'{s.Pattern}'"))));
        }
        return matches[0];
    }

    // ──────────────────────────────────────────────────────────────────────────
    // Shape classification (kept — needed for planning)

    private static MethodClassification ClassifyMethodShape(IMethodSymbol method,
        GenerateNonTryOptionsAttributeInfo opts, KnownSymbols ks)
    {
        // sync bool + out T
        if (method.ReturnType.SpecialType == SpecialType.System_Boolean)
        {
            IParameterSymbol? outParam = null;
            foreach (var p in method.Parameters)
            {
                if (p.RefKind == RefKind.Out)
                {
                    if (outParam != null)
                        return new MethodClassification(MethodShape.NotEligible, null, isValueTask: false,
                            payloadType: null);
                    outParam = p;
                }
            }

            if (outParam != null)
                return new MethodClassification(MethodShape.SyncBoolOut, outParam, isValueTask: false,
                    payloadType: null);
            return new MethodClassification(MethodShape.NotEligible, null, isValueTask: false, payloadType: null);
        }

        // async Task<(bool,T)> / ValueTask<(bool,T)>
        if ((opts.AsyncCandidateStrategy & AsyncCandidateStrategy.TupleBooleanAndValue) != 0)
        {
            if (method.ReturnType is INamedTypeSymbol rt && rt.IsGenericType)
            {
                if (ks.TaskOfT is not null && SymbolEqualityComparer.Default.Equals(rt.OriginalDefinition, ks.TaskOfT))
                {
                    var tArg = rt.TypeArguments[0];
                    if (TryGetTupleBoolPayload(tArg, out var payload))
                        return new MethodClassification(MethodShape.AsyncTuple, null, isValueTask: false,
                            payloadType: payload);
                }

                if (ks.ValueTaskOfT is not null &&
                    SymbolEqualityComparer.Default.Equals(rt.OriginalDefinition, ks.ValueTaskOfT))
                {
                    var tArg = rt.TypeArguments[0];
                    if (TryGetTupleBoolPayload(tArg, out var payload))
                        return new MethodClassification(MethodShape.AsyncTuple, null, isValueTask: true,
                            payloadType: payload);
                }
            }
        }

        return new MethodClassification(MethodShape.NotEligible, null, isValueTask: false, payloadType: null);

        static bool TryGetTupleBoolPayload(ITypeSymbol t, out ITypeSymbol? payload)
        {
            payload = null;
            if (t is INamedTypeSymbol nt && nt.IsTupleType)
            {
                var elems = nt.TupleElements;
                if (elems.Length == 2 && elems[0].Type.SpecialType == SpecialType.System_Boolean)
                {
                    payload = elems[1].Type;
                    return true;
                }
                return false;
            }

            if (t is INamedTypeSymbol nt2 && nt2.Arity == 2)
            {
                if (nt2.MetadataName.StartsWith("ValueTuple`2", StringComparison.Ordinal) &&
                    IsInSystemNamespace(nt2.ContainingNamespace))
                {
                    var args = nt2.TypeArguments;
                    if (args.Length == 2 && args[0].SpecialType == SpecialType.System_Boolean)
                    {
                        payload = args[1];
                        return true;
                    }
                }
            }
            return false;

            static bool IsInSystemNamespace(INamespaceSymbol? ns)
            {
                while (ns is not null && !ns.IsGlobalNamespace)
                {
                    if (ns.Name == "System" && (ns.ContainingNamespace?.IsGlobalNamespace ?? true))
                        return true;
                    ns = ns.ContainingNamespace;
                }
                return false;
            }
        }
    }

    // ──────────────────────────────────────────────────────────────────────────
    // Options (kept — needed for planning)

    internal static GenerateNonTryOptionsAttributeInfo GetEffectiveOptions(KnownSymbols ks, INamedTypeSymbol type)
    {
        foreach (var ad in type.GetAttributes())
            if (SymbolEqualityComparer.Default.Equals(ad.AttributeClass, ks.GenerateNonTryOptionsAttribute))
                return AttributeConverters.ToOptions(ad);
        foreach (var ad in type.ContainingAssembly.GetAttributes())
            if (SymbolEqualityComparer.Default.Equals(ad.AttributeClass, ks.GenerateNonTryOptionsAttribute))
                return AttributeConverters.ToOptions(ad);
        return new GenerateNonTryOptionsAttributeInfo();
    }

    // ──────────────────────────────────────────────────────────────────────────
    // Containers

    private static MemberDeclarationSyntax BuildTargetTypeDeclaration(INamedTypeSymbol type,
        IReadOnlyList<MethodDeclarationSyntax> members)
    {
        var identifier = SyntaxFactory.Identifier(type.Name);
        var modifiers = SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PartialKeyword));
        TypeDeclarationSyntax decl = type.TypeKind switch
        {
            TypeKind.Interface => SyntaxFactory.InterfaceDeclaration(identifier).WithModifiers(modifiers),
            TypeKind.Structure => SyntaxFactory.StructDeclaration(identifier).WithModifiers(modifiers),
            _ => SyntaxFactory.ClassDeclaration(identifier).WithModifiers(modifiers)
        };

        return decl.WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(members));
    }

    private static MemberDeclarationSyntax BuildExtensionsContainer(INamedTypeSymbol type,
        IReadOnlyList<MethodDeclarationSyntax> methods)
    {
        var extName = SyntaxFactory.Identifier($"{type.Name}_NonTryExtensions");
        var decl = SyntaxFactory.ClassDeclaration(extName)
            .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                SyntaxFactory.Token(SyntaxKind.StaticKeyword)));
        return decl.WithMembers(SyntaxFactory.List<MemberDeclarationSyntax>(methods));
    }

    // ──────────────────────────────────────────────────────────────────────────
    // Tiny helpers kept local

    private static string ComputeGeneratedName(string original, GenerateNonTryMethodAttributeInfoWithValidPattern info)
    {
        var m = info.Pattern.Match(original);
        Debug.Assert(m.Success);
        return m.Groups[1].Value;
    }

    private static ITypeSymbol AdjustForReturnStrategy(ITypeSymbol t, ReturnGenerationStrategy strat)
    {
        if (strat == ReturnGenerationStrategy.Verbatim) return t;
        if (t is INamedTypeSymbol nt && nt.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            return nt.TypeArguments[0];
        if (t.NullableAnnotation == NullableAnnotation.Annotated && (t.IsReferenceType || t.IsAnonymousType))
            return t.WithNullableAnnotation(NullableAnnotation.NotAnnotated);
        return t;
    }

    private static bool ShouldUnwrapNullable(ITypeSymbol originalType, ReturnGenerationStrategy strat)
        => strat == ReturnGenerationStrategy.TrueMeansNotNull
           && originalType is INamedTypeSymbol nt
           && nt.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T;

    private static bool NeedsInReceiver(IMethodSymbol m)
        => m.ContainingType.IsValueType && !m.IsStatic && m.IsReadOnly;

    private static bool NeedsRefReceiver(IMethodSymbol m)
        => m.ContainingType.IsValueType && !m.IsStatic && !m.IsReadOnly;

    private static ImmutableArray<ITypeParameterSymbol> CollectLiftedReceiverTypeParams(INamedTypeSymbol receiver)
    {
        if (receiver == null || receiver.TypeArguments.Length == 0)
            return ImmutableArray<ITypeParameterSymbol>.Empty;

        var list = new List<ITypeParameterSymbol>();
        foreach (var ta in receiver.TypeArguments)
            if (ta is ITypeParameterSymbol tp)
                list.Add(tp);

        return list.Count == 0 ? ImmutableArray<ITypeParameterSymbol>.Empty : [..list];
    }
}
