using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MBW.Generators.GeneratorHelpers;

[Generator]
public sealed class SymbolExtensionsGenerator : IIncrementalGenerator
{
    private const string GenerateSymbolExtensionsAttributeName = "MBW.Generators.GeneratorHelpers.GenerateSymbolExtensionsAttribute";
    private const string SymbolNameExtensionAttributeName = "MBW.Generators.GeneratorHelpers.SymbolNameExtensionAttribute";
    private const string NamespaceNameExtensionAttributeName = "MBW.Generators.GeneratorHelpers.NamespaceNameExtensionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.SyntaxProvider.ForAttributeWithMetadataName(
            GenerateSymbolExtensionsAttributeName,
            static (node, _) => node is TypeDeclarationSyntax,
            static (ctx, _) => GetTypeToGenerate(ctx))
            .Where(static t => t is not null)
            .Select(static (t, _) => t!);

        context.RegisterSourceOutput(types, static (spc, t) => Generate(spc, t));
    }

    private static TypeToGenerate? GetTypeToGenerate(GeneratorAttributeSyntaxContext ctx)
    {
        var typeSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var attr = ctx.Attributes[0];

        string? name = null;
        string? nsOverride = null;
        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Name))
                name = kv.Value.Value as string;
            else if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Namespace))
                nsOverride = kv.Value.Value as string;
        }

        var className = name ?? typeSymbol.Name + "Extensions";
        var namespaceName = nsOverride ?? "Microsoft.CodeAnalysis";
        var accessibility = typeSymbol.DeclaredAccessibility;

        var fields = new List<FieldToGenerate>();

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IFieldSymbol field)
                continue;

            foreach (var fa in field.GetAttributes())
            {
                var attrName = fa.AttributeClass?.ToDisplayString();
                if (attrName == SymbolNameExtensionAttributeName)
                {
                    var methodName = GetNamedArgument(fa, "MethodName") ?? field.Name;
                    if (field.HasConstantValue && field.ConstantValue is string fqn && !string.IsNullOrEmpty(fqn))
                        fields.Add(new FieldToGenerate(FieldKind.TypeName, methodName, fqn));
                }
                else if (attrName == NamespaceNameExtensionAttributeName)
                {
                    var methodName = GetNamedArgument(fa, "MethodName") ?? field.Name;
                    if (field.HasConstantValue && field.ConstantValue is string fqn && !string.IsNullOrEmpty(fqn))
                        fields.Add(new FieldToGenerate(FieldKind.NamespaceName, methodName, fqn));
                }
            }
        }

        if (fields.Count == 0)
            return null;

        return new TypeToGenerate(className, namespaceName, accessibility, fields);
    }

    private static string? GetNamedArgument(AttributeData attr, string name)
    {
        foreach (var kv in attr.NamedArguments)
            if (kv.Key == name)
                return kv.Value.Value as string;
        return null;
    }

    private static void Generate(SourceProductionContext context, TypeToGenerate type)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.CodeAnalysis;");
        sb.AppendLine();
        sb.Append("namespace ");
        sb.Append(type.Namespace);
        sb.AppendLine(";");
        sb.AppendLine();
        sb.Append(GetAccessibility(type.Accessibility));
        sb.Append(" static class ");
        sb.Append(type.ClassName);
        sb.AppendLine();
        sb.AppendLine("{");

        foreach (var field in type.Fields)
        {
            if (field.Kind == FieldKind.TypeName)
                GenerateTypeMethod(sb, field);
            else
                GenerateNamespaceMethods(sb, field);
        }

        sb.AppendLine("}");

        context.AddSource(type.ClassName + ".g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string GetAccessibility(Accessibility accessibility)
        => accessibility == Accessibility.Public ? "public" : "internal";

    private static void GenerateTypeMethod(StringBuilder sb, FieldToGenerate field)
    {
        var (nsSegments, typeSegments) = ParseTypeFqn(field.Fqn);
        var methodSuffix = field.MethodName;

        sb.Append("    public static bool IsNamedExactlyType");
        sb.Append(methodSuffix);
        sb.AppendLine("(this ISymbol? symbol)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (symbol is not INamedTypeSymbol t0) return false;");
        sb.Append("        if (!string.Equals(t0.MetadataName, \"");
        sb.Append(typeSegments[typeSegments.Length - 1]);
        sb.AppendLine("\", StringComparison.Ordinal)) return false;");

        string prevVar = "t0";
        for (int i = typeSegments.Length - 2, idx = 1; i >= 0; i--, idx++)
        {
            var varName = $"t{idx}";
            sb.Append("        var ");
            sb.Append(varName);
            sb.Append(" = ");
            sb.Append(prevVar);
            sb.AppendLine(".ContainingType;");
            sb.Append("        if (");
            sb.Append(varName);
            sb.AppendLine(" is null) return false;");
            sb.Append("        if (!string.Equals(");
            sb.Append(varName);
            sb.Append(".MetadataName, \"");
            sb.Append(typeSegments[i]);
            sb.AppendLine("\", StringComparison.Ordinal)) return false;");
            prevVar = varName;
        }

        sb.Append("        if (");
        sb.Append(prevVar);
        sb.AppendLine(".ContainingType is not null) return false;");
        sb.Append("        var ns = ");
        sb.Append(prevVar);
        sb.AppendLine(".ContainingNamespace;");

        for (int i = nsSegments.Length - 1; i >= 0; i--)
        {
            sb.Append("        if (!string.Equals(ns.Name, \"");
            sb.Append(nsSegments[i]);
            sb.AppendLine("\", StringComparison.Ordinal)) return false;");
            sb.AppendLine("        ns = ns.ContainingNamespace;");
        }
        sb.AppendLine("        return ns.IsGlobalNamespace;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateNamespaceMethods(StringBuilder sb, FieldToGenerate field)
    {
        var segments = ParseNamespaceFqn(field.Fqn);
        var suffix = field.MethodName;

        // ISymbol overloads
        sb.Append("    public static bool IsInNamespace");
        sb.Append(suffix);
        sb.AppendLine("(this ISymbol? symbol)");
        sb.AppendLine("    {");
        sb.Append("        return IsInNamespace");
        sb.Append(suffix);
        sb.AppendLine("(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.Append("    public static bool IsExactlyInNamespace");
        sb.Append(suffix);
        sb.AppendLine("(this ISymbol? symbol)");
        sb.AppendLine("    {");
        sb.Append("        return IsExactlyNamespace");
        sb.Append(suffix);
        sb.AppendLine("(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);");
        sb.AppendLine("    }");
        sb.AppendLine();

        // INamespaceSymbol overloads
        sb.Append("    public static bool IsInNamespace");
        sb.Append(suffix);
        sb.AppendLine("(this INamespaceSymbol? ns)");
        sb.AppendLine("    {");
        sb.AppendLine("        for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace)");
        sb.AppendLine("        {");
        sb.Append("            if (string.Equals(current.Name, \"");
        sb.Append(segments[segments.Length - 1]);
        sb.AppendLine("\", StringComparison.Ordinal))");
        sb.AppendLine("            {");
        if (segments.Length == 1)
        {
            sb.AppendLine("                return true;");
        }
        else
        {
            string prevVar = "current";
            for (int i = segments.Length - 2, idx = 0; i >= 0; i--, idx++)
            {
                var varName = $"ns{idx}";
                sb.Append("                var ");
                sb.Append(varName);
                sb.Append(" = ");
                sb.Append(prevVar);
                sb.AppendLine(".ContainingNamespace;");
                sb.Append("                if (!string.Equals(");
                sb.Append(varName);
                sb.Append(".Name, \"");
                sb.Append(segments[i]);
                sb.AppendLine("\", StringComparison.Ordinal)) continue;");
                prevVar = varName;
            }
            sb.AppendLine("                return true;");
        }
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine("        return false;");
        sb.AppendLine("    }");
        sb.AppendLine();

        sb.Append("    public static bool IsExactlyNamespace");
        sb.Append(suffix);
        sb.AppendLine("(this INamespaceSymbol? ns)");
        sb.AppendLine("    {");
        sb.AppendLine("        if (ns is null) return false;");
        sb.Append("        if (!string.Equals(ns.Name, \"");
        sb.Append(segments[segments.Length - 1]);
        sb.AppendLine("\", StringComparison.Ordinal)) return false;");
        for (int i = segments.Length - 2; i >= 0; i--)
        {
            sb.AppendLine("        ns = ns.ContainingNamespace;");
            sb.Append("        if (!string.Equals(ns.Name, \"");
            sb.Append(segments[i]);
            sb.AppendLine("\", StringComparison.Ordinal)) return false;");
        }
        sb.AppendLine("        ns = ns.ContainingNamespace;");
        sb.AppendLine("        return ns.IsGlobalNamespace;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static (string[] NamespaceSegments, string[] TypeSegments) ParseTypeFqn(string fqn)
    {
        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);
        int lastDot = fqn.LastIndexOf('.') ;
        string nsPart = lastDot >= 0 ? fqn.Substring(0, lastDot) : string.Empty;
        string typePart = lastDot >= 0 ? fqn.Substring(lastDot + 1) : fqn;
        var nsSegments = nsPart.Length == 0 ? Array.Empty<string>() : nsPart.Split('.');
        var typeSegments = typePart.Split('+');
        return (nsSegments, typeSegments);
    }

    private static string[] ParseNamespaceFqn(string fqn)
    {
        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);
        return fqn.Length == 0 ? Array.Empty<string>() : fqn.Split('.');
    }

    private sealed record TypeToGenerate(string ClassName, string Namespace, Accessibility Accessibility, List<FieldToGenerate> Fields);

    private sealed record FieldToGenerate(FieldKind Kind, string MethodName, string Fqn);

    private enum FieldKind
    {
        TypeName,
        NamespaceName
    }
}
