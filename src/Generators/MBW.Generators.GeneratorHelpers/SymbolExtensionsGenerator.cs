using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using MBW.Generators.Common.Helpers;
using MBW.Generators.GeneratorHelpers.Attributes;
using MBW.Generators.GeneratorHelpers.Models;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MBW.Generators.GeneratorHelpers;

[Generator]
public sealed class SymbolExtensionsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.SyntaxProvider.ForAttributeWithMetadataName(
                KnownSymbols.GenerateSymbolExtensionsAttributeName,
                static (node, _) => node is TypeDeclarationSyntax,
                static (ctx, _) => GetTypeToGenerate(ctx))
            .Where(static t => t.HasValue)
            .Select(static (t, _) => t!.Value);

        context.RegisterSourceOutput(types, (spc, t) =>
        {
            foreach (var diag in t.Diagnostics)
                spc.ReportDiagnostic(diag);

            if (t.Fields.Length == 0)
                return;

            var body = new StringBuilder();
            foreach (var field in t.Fields)
            {
                if (field.Kind == FieldKind.Type)
                    body.Append(GenerateTypeMethod(field));
                else
                    body.Append(GenerateNamespaceMethods(field));
            }

            string source = $$"""
                              // <auto-generated/>
                              #nullable enable
                              using System;
                              using Microsoft.CodeAnalysis;

                              namespace {{t.Namespace}};

                              {{GetAccessibility(t.Accessibility)}} static class {{t.ClassName}}
                              {
                              {{body}}
                              }
                              """;

            string hintName = GenerationHelpers.GetHintName("GeneratorHelpers", t.Type);
            spc.AddSource(hintName, SourceText.From(source, Encoding.UTF8));
        });
    }

    private static TypeToGenerate? GetTypeToGenerate(GeneratorAttributeSyntaxContext ctx)
    {
        var typeSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var attr = ctx.Attributes[0];

        string? name = null;
        string? nsOverride = null;
        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Name))
                name = kv.Value.Value as string;
            else if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Namespace))
                nsOverride = kv.Value.Value as string;
        }

        var className = name ?? typeSymbol.Name + "Extensions";
        var namespaceName = nsOverride ?? "Microsoft.CodeAnalysis";
        var accessibility = typeSymbol.DeclaredAccessibility;

        var fields = new List<FieldInfo>();
        var diagnostics = new List<Diagnostic>();

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IFieldSymbol field)
                continue;

            foreach (var fa in field.GetAttributes())
            {
                var attrName = fa.AttributeClass?.ToDisplayString();
                FieldKind? kind = attrName switch
                {
                    KnownSymbols.SymbolNameExtensionAttributeName => FieldKind.Type,
                    KnownSymbols.NamespaceNameExtensionAttributeName => FieldKind.Namespace,
                    _ => null
                };
                if (kind is null)
                    continue;

                if (!(field.IsConst && field.Type.SpecialType == SpecialType.System_String &&
                      field.ConstantValue is string constValue && !string.IsNullOrWhiteSpace(constValue)))
                {
                    diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidFieldTarget, field.Locations[0], field.Name));
                    continue;
                }

                string methodBase = GetNamedArgument(fa, "MethodName") ?? field.Name;

                if (kind == FieldKind.Type)
                {
                    if (!TryParseTypeFqn(constValue, out var typeData))
                    {
                        diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidTypeFqn, field.Locations[0], field.Name,
                            constValue));
                        continue;
                    }

                    fields.Add(new FieldInfo(kind.Value, methodBase, typeData.NamespaceSegments,
                        typeData.TypeSegments, typeData.Normalized, field.Locations[0]));
                }
                else
                {
                    if (!TryParseNamespaceFqn(constValue, out var nsSegments, out var normalized))
                    {
                        diagnostics.Add(Diagnostic.Create(Diagnostics.InvalidNamespaceFqn, field.Locations[0],
                            field.Name, constValue));
                        continue;
                    }

                    fields.Add(new FieldInfo(kind.Value, methodBase, nsSegments, null, normalized,
                        field.Locations[0]));
                }
            }
        }

        if (fields.Count == 0)
        {
            return new TypeToGenerate(typeSymbol, className, namespaceName, accessibility,
                [], diagnostics, typeSymbol.Locations[0]);
        }

        var byTarget = fields.GroupBy(f => f.NormalizedTarget);
        foreach (var group in byTarget)
        {
            bool first = true;
            foreach (var field in group)
            {
                if (first)
                {
                    first = false;
                    continue;
                }

                diagnostics.Add(Diagnostic.Create(Diagnostics.DuplicateTarget, field.Location, field.MethodBaseName,
                    group.Key));
                field.Generate = false;
            }
        }

        var byName = fields.Where(f => f.Generate).GroupBy(f => f.MethodBaseName);
        foreach (var group in byName)
        {
            int idx = 1;
            foreach (var field in group)
            {
                if (idx == 1)
                {
                    field.MethodName = field.MethodBaseName;
                }
                else
                {
                    field.MethodName = field.MethodBaseName + "_" + idx;
                    diagnostics.Add(Diagnostic.Create(Diagnostics.DuplicateMethodName, field.Location,
                        field.MethodBaseName, field.MethodName));
                }

                idx++;
            }
        }

        var fieldsToGenerate = fields.Where(f => f.Generate)
            .Select(f => new FieldToGenerate(f.Kind, f.MethodName!, f.NamespaceSegments,
                f.TypeSegments, f.Location)).ToArray();

        return new TypeToGenerate(typeSymbol, className, namespaceName, accessibility, fieldsToGenerate,
            diagnostics, typeSymbol.Locations[0]);
    }

    private static string? GetNamedArgument(AttributeData attr, string name)
    {
        foreach (var kv in attr.NamedArguments)
            if (kv.Key == name)
                return kv.Value.Value as string;
        return null;
    }

    private static string GetAccessibility(Accessibility accessibility) =>
        accessibility == Accessibility.Public ? "public" : "internal";

    private static string GenerateTypeMethod(FieldToGenerate field)
    {
        var methodSuffix = field.MethodName;
        var innermost = field.TypeSegments![field.TypeSegments.Length - 1];

        // Build dynamic chains for containing types
        var containingTypes = new StringBuilder();
        string current = "t0";
        for (int i = field.TypeSegments.Length - 2, idx = 1; i >= 0; i--, idx++)
        {
            var seg = field.TypeSegments[i];
            var selector = seg.UseMetadataName ? "MetadataName" : "Name";
            containingTypes.Append($"""
                                            var t{idx} = {current}.ContainingType;
                                            if (t{idx} is null || !t{idx}.{selector}.Equals("{seg.Value}", StringComparison.Ordinal)) return false;
                                    """);
            current = $"t{idx}";
        }

        // Build namespace checks
        var nsChecks = new StringBuilder();
        for (int i = field.NamespaceSegments.Length - 1; i >= 0; i--)
        {
            var seg = field.NamespaceSegments[i];
            nsChecks.Append($"""
                                     if (ns is null || !ns.Name.Equals("{seg}", StringComparison.Ordinal)) return false;
                                     ns = ns.ContainingNamespace;
                             """);
        }

        var head = innermost.UseMetadataName
            ? $"""
                       if (symbol is not INamedTypeSymbol t0) return false;
                       if (!t0.MetadataName.Equals("{innermost.Value}", StringComparison.Ordinal)) return false;
               """
            : $"""
                       if (symbol is null) return false;
                       if (!symbol.Name.Equals("{innermost.Value}", StringComparison.Ordinal)) return false;
                       if (symbol is not INamedTypeSymbol t0) return false;
               """;

        return $$"""
                     public static bool IsNamedExactlyType{{methodSuffix}}(this ISymbol? symbol)
                     {
                 {{head}}{{containingTypes}}        if ({{current}}.ContainingType is not null) return false;
                         var ns = {{current}}.ContainingNamespace;
                 {{nsChecks}}        return ns != null && ns.IsGlobalNamespace;
                     }

                 """;
    }

    private static string GenerateNamespaceMethods(FieldToGenerate field)
    {
        var suffix = field.MethodName;
        var segments = field.NamespaceSegments;

        // Build the aligned "IsInNamespace" ladder
        var inNsChecks = new StringBuilder();
        for (int i = segments.Length - 1; i >= 0; i--)
        {
            var seg = segments[i];
            inNsChecks.Append($"""
                                       if (ns is null || !ns.Name.Equals("{seg}", StringComparison.Ordinal)) return false;
                                       ns = ns.ContainingNamespace;
                               """);
        }

        // Build the exact match ladder
        var exactChecks = new StringBuilder();
        for (int i = segments.Length - 2; i >= 0; i--)
        {
            var seg = segments[i];
            exactChecks.Append($"""
                                        ns = ns.ContainingNamespace;
                                        if (ns is null || !ns.Name.Equals("{seg}", StringComparison.Ordinal)) return false;
                                """);
        }

        return $$"""
                     public static bool IsInNamespace{{suffix}}(this ISymbol? symbol)
                     {
                         return IsInNamespace{{suffix}}(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                     }

                     public static bool IsExactlyInNamespace{{suffix}}(this ISymbol? symbol)
                     {
                         return IsExactlyNamespace{{suffix}}(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                     }

                     public static bool IsInNamespace{{suffix}}(this INamespaceSymbol? ns)
                     {
                         if (ns is null) return false;
                         int depth = 0;
                         for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace) depth++;
                         if (depth < {{segments.Length}}) return false;
                         for (int i = 0; i < depth - {{segments.Length}}; i++) ns = ns!.ContainingNamespace;
                 {{inNsChecks}}        return true;
                     }

                     public static bool IsExactlyNamespace{{suffix}}(this INamespaceSymbol? ns)
                     {
                         if (ns is null) return false;
                         if (!ns.Name.Equals("{{segments[segments.Length - 1]}}", StringComparison.Ordinal)) return false;
                 {{exactChecks}}        ns = ns.ContainingNamespace;
                         return ns != null && ns.IsGlobalNamespace;
                     }

                 """;
    }

    private static bool TryParseTypeFqn(string fqn, out TypeFqn typeFqn)
    {
        typeFqn = default;

        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);

        int lastDot = fqn.LastIndexOf('.');
        if (lastDot < 0)
            return false;

        string nsPart = fqn.Substring(0, lastDot);
        string typePart = fqn.Substring(lastDot + 1);

        var nsSegments = nsPart.Split('.');
        if (nsSegments.Length == 0 || nsSegments.Any(s => string.IsNullOrWhiteSpace(s)))
            return false;

        var typeSegmentsRaw = typePart.Split('+');
        if (typeSegmentsRaw.Length == 0 || typeSegmentsRaw.Any(s => string.IsNullOrWhiteSpace(s)))
            return false;

        var typeSegments = typeSegmentsRaw
            .Select(s => new TypeSegment(s, s.Contains('`')))
            .ToArray();

        string normalized = string.Join(".", nsSegments) + "." + string.Join("+", typeSegmentsRaw);

        typeFqn = new TypeFqn(nsSegments, typeSegments, normalized);
        return true;
    }

    private static bool TryParseNamespaceFqn(string fqn, out string[] segments, out string normalized)
    {
        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);

        var parts = fqn.Split('.');
        if (parts.Length == 0 || parts.Any(s => string.IsNullOrWhiteSpace(s)))
        {
            segments = [];
            normalized = string.Empty;
            return false;
        }

        segments = parts;
        normalized = string.Join(".", parts);
        return true;
    }
}