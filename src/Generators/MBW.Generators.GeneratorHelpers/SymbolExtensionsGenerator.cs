using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace MBW.Generators.GeneratorHelpers;

[Generator]
public sealed class SymbolExtensionsGenerator : IIncrementalGenerator
{
    private const string GenerateSymbolExtensionsAttributeName =
        "MBW.Generators.GeneratorHelpers.GenerateSymbolExtensionsAttribute";

    private const string SymbolNameExtensionAttributeName =
        "MBW.Generators.GeneratorHelpers.SymbolNameExtensionAttribute";

    private const string NamespaceNameExtensionAttributeName =
        "MBW.Generators.GeneratorHelpers.NamespaceNameExtensionAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var types = context.SyntaxProvider.ForAttributeWithMetadataName(
                GenerateSymbolExtensionsAttributeName,
                static (node, _) => node is TypeDeclarationSyntax,
                static (ctx, _) => GetTypeToGenerate(ctx))
            .Where(static t => t.HasValue)
            .Select(static (t, _) => t!.Value);

        context.RegisterSourceOutput(types, static (spc, t) => Generate(spc, t));
    }

    private static TypeToGenerate? GetTypeToGenerate(GeneratorAttributeSyntaxContext ctx)
    {
        var typeSymbol = (INamedTypeSymbol)ctx.TargetSymbol;
        var attr = ctx.Attributes[0];

        string? name = null;
        string? nsOverride = null;
        foreach (var kv in attr.NamedArguments)
        {
            if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Name))
                name = kv.Value.Value as string;
            else if (kv.Key == nameof(GenerateSymbolExtensionsAttribute.Namespace))
                nsOverride = kv.Value.Value as string;
        }

        var className = name ?? typeSymbol.Name + "Extensions";
        var namespaceName = nsOverride ?? "Microsoft.CodeAnalysis";
        var accessibility = typeSymbol.DeclaredAccessibility;

        var fields = new List<FieldToGenerate>();

        foreach (var member in typeSymbol.GetMembers())
        {
            if (member is not IFieldSymbol field)
                continue;

            foreach (var fa in field.GetAttributes())
            {
                var attrName = fa.AttributeClass?.ToDisplayString();
                if (attrName == SymbolNameExtensionAttributeName)
                {
                    var methodName = GetNamedArgument(fa, "MethodName") ?? field.Name;
                    if (field.HasConstantValue && field.ConstantValue is string fqn && !string.IsNullOrEmpty(fqn))
                        fields.Add(new FieldToGenerate(FieldKind.TypeName, methodName, fqn));
                }
                else if (attrName == NamespaceNameExtensionAttributeName)
                {
                    var methodName = GetNamedArgument(fa, "MethodName") ?? field.Name;
                    if (field.HasConstantValue && field.ConstantValue is string fqn && !string.IsNullOrEmpty(fqn))
                        fields.Add(new FieldToGenerate(FieldKind.NamespaceName, methodName, fqn));
                }
            }
        }

        if (fields.Count == 0)
            return null;

        return new TypeToGenerate(className, namespaceName, accessibility, fields);
    }

    private static string? GetNamedArgument(AttributeData attr, string name)
    {
        foreach (var kv in attr.NamedArguments)
            if (kv.Key == name)
                return kv.Value.Value as string;
        return null;
    }

    private static void Generate(SourceProductionContext context, TypeToGenerate type)
    {
        var sb = new StringBuilder();

        sb.AppendLine("""
                      // <auto-generated/>
                      using System;
                      using Microsoft.CodeAnalysis;

                      """);

        sb.AppendLine($$"""
                        namespace {{type.Namespace}};

                        {{GetAccessibility(type.Accessibility)}} static class {{type.ClassName}}
                        {
                        """);

        foreach (var field in type.Fields)
        {
            if (field.Kind == FieldKind.TypeName)
                GenerateTypeMethod(sb, field);
            else
                GenerateNamespaceMethods(sb, field);
        }

        sb.AppendLine("}");

        context.AddSource(type.ClassName + ".g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static string GetAccessibility(Accessibility accessibility)
        => accessibility == Accessibility.Public ? "public" : "internal";

    private static void GenerateTypeMethod(StringBuilder sb, FieldToGenerate field)
    {
        var (nsSegments, typeSegments) = ParseTypeFqn(field.Fqn);
        var methodSuffix = field.MethodName;

        sb.AppendLine($$"""
                            public static bool IsNamedExactlyType{{methodSuffix}}(this ISymbol? symbol)
                            {
                                if (symbol is not INamedTypeSymbol t0) return false;
                                if (!string.Equals(t0.MetadataName, "{{typeSegments[typeSegments.Length - 1]}}", StringComparison.Ordinal)) return false;
                        """);

        string prevVar = "t0";
        for (int i = typeSegments.Length - 2, idx = 1; i >= 0; i--, idx++)
        {
            var varName = $"t{idx}";
            sb.AppendLine($$"""
                                    var {{varName}} = {{prevVar}}.ContainingType;
                                    if ({{varName}} is null) return false;
                                    if (!string.Equals({{varName}}.MetadataName, "{{typeSegments[i]}}", StringComparison.Ordinal)) return false;
                            """);
            prevVar = varName;
        }

        sb.AppendLine($$"""
                                if ({{prevVar}}.ContainingType is not null) return false;
                                var ns = {{prevVar}}.ContainingNamespace;
                        """);

        for (int i = nsSegments.Length - 1; i >= 0; i--)
        {
            sb.AppendLine($$"""
                                    if (!string.Equals(ns.Name, "{{nsSegments[i]}}", StringComparison.Ordinal)) return false;
                                    ns = ns.ContainingNamespace;
                            """);
        }

        sb.AppendLine("""
                              return ns.IsGlobalNamespace;
                          }

                      """);
    }

    private static void GenerateNamespaceMethods(StringBuilder sb, FieldToGenerate field)
    {
        var segments = ParseNamespaceFqn(field.Fqn);
        var suffix = field.MethodName;

        // ISymbol overloads
        sb.AppendLine($$"""
                            public static bool IsInNamespace{{suffix}}(this ISymbol? symbol)
                            {
                                return IsInNamespace{{suffix}}(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                            }

                            public static bool IsExactlyInNamespace{{suffix}}(this ISymbol? symbol)
                            {
                                return IsExactlyNamespace{{suffix}}(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                            }

                        """);

        // INamespaceSymbol overloads
        sb.AppendLine($$"""
                            public static bool IsInNamespace{{suffix}}(this INamespaceSymbol? ns)
                            {
                                for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace)
                                {
                                    if (string.Equals(current.Name, "{{segments[segments.Length - 1]}}", StringComparison.Ordinal))
                                    {
                        """);

        if (segments.Length == 1)
        {
            sb.AppendLine("""
                                  return true;
                          """);
        }
        else
        {
            string prevVar = "current";
            for (int i = segments.Length - 2, idx = 0; i >= 0; i--, idx++)
            {
                var varName = $"ns{idx}";
                sb.AppendLine($$"""
                                        var {{varName}} = {{prevVar}}.ContainingNamespace;
                                        if (!string.Equals({{varName}}.Name, "{{segments[i]}}", StringComparison.Ordinal)) continue;
                                """);
                prevVar = varName;
            }

            sb.AppendLine("""
                                  return true;
                          """);
        }

        sb.AppendLine("""
                                  }
                              }
                              return false;
                          }

                      """);

        sb.AppendLine($$"""
                            public static bool IsExactlyNamespace{{suffix}}(this INamespaceSymbol? ns)
                            {
                                if (ns is null) return false;
                                if (!string.Equals(ns.Name, "{{segments[segments.Length - 1]}}", StringComparison.Ordinal)) return false;
                        """);

        for (int i = segments.Length - 2; i >= 0; i--)
        {
            sb.AppendLine($$"""
                                    ns = ns.ContainingNamespace;
                                    if (!string.Equals(ns.Name, "{{segments[i]}}", StringComparison.Ordinal)) return false;
                            """);
        }

        sb.AppendLine("""
                              ns = ns.ContainingNamespace;
                              return ns.IsGlobalNamespace;
                          }

                      """);
    }

    private static (string[] NamespaceSegments, string[] TypeSegments) ParseTypeFqn(string fqn)
    {
        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);
        int lastDot = fqn.LastIndexOf('.');
        string nsPart = lastDot >= 0 ? fqn.Substring(0, lastDot) : string.Empty;
        string typePart = lastDot >= 0 ? fqn.Substring(lastDot + 1) : fqn;
        var nsSegments = nsPart.Length == 0 ? Array.Empty<string>() : nsPart.Split('.');
        var typeSegments = typePart.Split('+');
        return (nsSegments, typeSegments);
    }

    private static string[] ParseNamespaceFqn(string fqn)
    {
        if (fqn.StartsWith("global::", StringComparison.Ordinal))
            fqn = fqn.Substring("global::".Length);
        return fqn.Length == 0 ? Array.Empty<string>() : fqn.Split('.');
    }

    private readonly record struct TypeToGenerate(
        string ClassName,
        string Namespace,
        Accessibility Accessibility,
        List<FieldToGenerate> Fields);

    private readonly record struct FieldToGenerate(FieldKind Kind, string MethodName, string Fqn);

    private enum FieldKind
    {
        TypeName,
        NamespaceName
    }
}