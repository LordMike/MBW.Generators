# MBW.Generators.GeneratorHelpers

## About
Provides allocation-free extension methods for Roslyn symbols based on predefined type and namespace strings. Annotate a type with constants representing canonical symbols and the generator emits helper methods to quickly compare symbols without allocations or `ToDisplayString` calls.

Useful when analyzing large code bases where repeated string construction would otherwise hurt performance.

## Quick Start
- Install the `MBW.Generators.GeneratorHelpers` and `MBW.Generators.GeneratorHelpers.Attributes` packages.
- Apply `[GenerateSymbolExtensions]` to a `class` or `struct` containing annotated `const string` fields.
- Override the generated extensions class name and namespace via the attribute’s `Name` and `Namespace` properties. Defaults to `<TypeName>Extensions` in `Microsoft.CodeAnalysis`.
- Per-field `MethodName` overrides customise the method suffix for `[SymbolNameExtension]` and `[NamespaceNameExtension]`.
- Fully qualified strings support the `global::` prefix, nested types using `+`, and generic metadata names like ``Dictionary`2``.
- Attributes and generator ship in separate packages so you can opt out of running the generator.

## Example
```csharp
using MBW.Generators.GeneratorHelpers;
using MBW.Generators.GeneratorHelpers.Attributes;

[GenerateSymbolExtensions(Name = "KnownExtensions", Namespace = "My.Helpers")]
internal static class Known
{
    [SymbolNameExtension(MethodName = "Exception")]
    public const string ExceptionType = "global::System.Exception";
}
```
Generates
```csharp
// <auto-generated/>
using System;
using Microsoft.CodeAnalysis;

namespace My.Helpers;

internal static class KnownExtensions
{
    public static bool IsNamedExactlyTypeException(this ISymbol? symbol)
    {
        if (symbol is null) return false;
        if (!symbol.Name.Equals("Exception", StringComparison.Ordinal)) return false;
        if (symbol is not INamedTypeSymbol t0) return false;
        if (t0.ContainingType is not null) return false;
        var ns = t0.ContainingNamespace;
        if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
        ns = ns.ContainingNamespace;
        return ns != null && ns.IsGlobalNamespace;
    }
}
```

## Features
- Generates allocation-free helpers for types and namespaces.
- Handles nested and generic types, including names with `global::` and multiple containing types.
- Provides `ISymbol` and `INamespaceSymbol` overloads for namespace checks.
- Supports custom extension class name/namespace and per-field method name overrides.

## Attributes
- **GenerateSymbolExtensionsAttribute** – apply to a type to opt in. Controls generated class name and namespace.
- **SymbolNameExtensionAttribute** – place on a `const string` field containing a fully qualified type name. Optional `MethodName` override for the generated method suffix.
- **NamespaceNameExtensionAttribute** – place on a `const string` field containing a fully qualified namespace. Generates `IsInNamespaceN`, `IsExactlyInNamespaceN`, `IsInNamespaceN` (`INamespaceSymbol`), and `IsExactlyNamespaceN`. Optional `MethodName` override.

## More information
This project is provided as-is without support. Additional examples will be available in the [tests](../MBW.Generators.GeneratorHelpers.Tests).
