using System;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Threading.Tasks;
using MBW.Generators.GeneratorHelpers.Tests.Helpers;
using MBW.Generators.Tests.Common;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Xunit;

namespace MBW.Generators.GeneratorHelpers.Tests;

public class GenerationTests
{
    [Fact]
    public async Task TypeExactMatch_Unrolled()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [SymbolNameExtension(MethodName="Test")]
                                                                   public const string Target = "MBW.Generators.OverloadGenerator.Attributes.TransformOverloadAttribute";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;

                           namespace Microsoft.CodeAnalysis;

                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>MBW.Generators.OverloadGenerator.Attributes.TransformOverloadAttribute</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>MBW.Generators.OverloadGenerator.Attributes.TransformOverloadAttribute</c>.</returns>
                               public static bool IsNamedExactlyTypeTest(this ISymbol? symbol)
                               {
                                   if (symbol is null)
                                       return false;
                                   if (!symbol.Name.Equals("TransformOverloadAttribute", StringComparison.Ordinal))
                                       return false;
                                   if (symbol is not INamedTypeSymbol t0)
                                       return false;
                                   if (t0.ContainingType is not null)
                                       return false;
                                   
                                   var ns = t0.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("Attributes", StringComparison.Ordinal))
                                       return false;
                                   ns = ns.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("OverloadGenerator", StringComparison.Ordinal))
                                       return false;
                                   ns = ns.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("Generators", StringComparison.Ordinal))
                                       return false;
                                   ns = ns.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("MBW", StringComparison.Ordinal))
                                       return false;
                                   ns = ns.ContainingNamespace;
                                   return ns != null && ns.IsGlobalNamespace;
                               }
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task GlobalPrefix_Unrolled()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [SymbolNameExtension(MethodName="Exception")]
                                                                   public const string Target = "global::System.Exception";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>System.Exception</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>System.Exception</c>.</returns>
                               public static bool IsNamedExactlyTypeException(this ISymbol? symbol)
                               {
                                   if (symbol is null) return false;
                                   if (!symbol.Name.Equals("Exception", StringComparison.Ordinal)) return false;
                                   if (symbol is not INamedTypeSymbol t0) return false;        if (t0.ContainingType is not null) return false;
                                   var ns = t0.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return ns != null && ns.IsGlobalNamespace;
                               }
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task NestedType_Unrolled()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [SymbolNameExtension(MethodName="Nested")]
                                                                   public const string Target = "System.IO.Compression.ZipArchive+Entry";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;

                           namespace Microsoft.CodeAnalysis;

                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>System.IO.Compression.ZipArchive+Entry</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>System.IO.Compression.ZipArchive+Entry</c>.</returns>
                               public static bool IsNamedExactlyTypeNested(this ISymbol? symbol)
                               {
                                   if (symbol is null) return false;
                                   if (!symbol.Name.Equals("Entry", StringComparison.Ordinal)) return false;
                                   if (symbol is not INamedTypeSymbol t0) return false;        var t1 = t0.ContainingType;
                                   if (t1 is null || !t1.Name.Equals("ZipArchive", StringComparison.Ordinal)) return false;        if (t1.ContainingType is not null) return false;
                                   var ns = t1.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("Compression", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        if (ns is null || !ns.Name.Equals("IO", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return ns != null && ns.IsGlobalNamespace;
                               }
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task NestedTypeInNestedType_Unrolled()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [SymbolNameExtension(MethodName="Deep")]
                                                                   public const string Target = "System.Outer+Inner+Deep";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>System.Outer+Inner+Deep</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>System.Outer+Inner+Deep</c>.</returns>
                               public static bool IsNamedExactlyTypeDeep(this ISymbol? symbol)
                               {
                                   if (symbol is null) return false;
                                   if (!symbol.Name.Equals("Deep", StringComparison.Ordinal)) return false;
                                   if (symbol is not INamedTypeSymbol t0) return false;        var t1 = t0.ContainingType;
                                   if (t1 is null || !t1.Name.Equals("Inner", StringComparison.Ordinal)) return false;        var t2 = t1.ContainingType;
                                   if (t2 is null || !t2.Name.Equals("Outer", StringComparison.Ordinal)) return false;        if (t2.ContainingType is not null) return false;
                                   var ns = t2.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return ns != null && ns.IsGlobalNamespace;
                               }
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task GenericType_UsesMetadataName()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [SymbolNameExtension(MethodName="Dict")]
                                                                   public const string Target = "System.Collections.Generic.Dictionary`2";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>System.Collections.Generic.Dictionary`2</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>System.Collections.Generic.Dictionary`2</c>.</returns>
                               public static bool IsNamedExactlyTypeDict(this ISymbol? symbol)
                               {
                                   if (symbol is not INamedTypeSymbol t0) return false;
                                   if (!t0.MetadataName.Equals("Dictionary`2", StringComparison.Ordinal)) return false;        if (t0.ContainingType is not null) return false;
                                   var ns = t0.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("Generic", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        if (ns is null || !ns.Name.Equals("Collections", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return ns != null && ns.IsGlobalNamespace;
                               }
                           
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task NamespaceMethods_Unrolled()
    {
        var (output, diags) = await TestsHelper.RunHelperAsync("""
                                                               [GenerateSymbolExtensions]
                                                               public static class Known
                                                               {
                                                                   [NamespaceNameExtension(MethodName="SystemCollections")]
                                                                   public const string Target = "System.Collections";
                                                               }
                                                               """);

        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is <c>System.Collections</c> or nested within it.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is declared in <c>System.Collections</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceSystemCollections(this ISymbol? symbol)
                               {
                                   return IsInNamespaceSystemCollections(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is exactly <c>System.Collections</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if the namespace is exactly <c>System.Collections</c>.</returns>
                               public static bool IsExactlyInNamespaceSystemCollections(this ISymbol? symbol)
                               {
                                   return IsExactlyNamespaceSystemCollections(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is <c>System.Collections</c> or nested within it.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> is <c>System.Collections</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceSystemCollections(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   int depth = 0;
                                   for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace) depth++;
                                   if (depth < 2) return false;
                                   for (int i = 0; i < depth - 2; i++) ns = ns!.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("Collections", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return true;
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is exactly <c>System.Collections</c>.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> equals <c>System.Collections</c>.</returns>
                               public static bool IsExactlyNamespaceSystemCollections(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   if (!ns.Name.Equals("Collections", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;        ns = ns.ContainingNamespace;
                                   return ns != null && ns.IsGlobalNamespace;
                               }
                           
                           }
                           """, output, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task VisibilityMatches()
    {
        var (outputPub, diagsPub) = await TestsHelper.RunHelperAsync("""
                                                                     [GenerateSymbolExtensions]
                                                                     public class KnownPublic
                                                                     {
                                                                         [NamespaceNameExtension]
                                                                         public const string Ns = "System";
                                                                     }
                                                                     """);

        Assert.Empty(diagsPub);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownPublicExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is declared in <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceNs(this ISymbol? symbol)
                               {
                                   return IsInNamespaceNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is exactly <c>System</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if the namespace is exactly <c>System</c>.</returns>
                               public static bool IsExactlyInNamespaceNs(this ISymbol? symbol)
                               {
                                   return IsExactlyNamespaceNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> is <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   int depth = 0;
                                   for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace) depth++;
                                   if (depth < 1) return false;
                                   for (int i = 0; i < depth - 1; i++) ns = ns!.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return true;
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is exactly <c>System</c>.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> equals <c>System</c>.</returns>
                               public static bool IsExactlyNamespaceNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   if (!ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;
                                   return ns != null && ns.IsGlobalNamespace;
                               }
                           
                           }
                           """, outputPub, SyntaxHelper.ComparisonOptions.None);

        var (outputInt, diagsInt) = await TestsHelper.RunHelperAsync("""
                                                                     [GenerateSymbolExtensions]
                                                                     internal class KnownInternal
                                                                     {
                                                                         [NamespaceNameExtension]
                                                                         public const string Ns = "System";
                                                                     }
                                                                     """);

        Assert.Empty(diagsInt);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           internal static class KnownInternalExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is declared in <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceNs(this ISymbol? symbol)
                               {
                                   return IsInNamespaceNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is exactly <c>System</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if the namespace is exactly <c>System</c>.</returns>
                               public static bool IsExactlyInNamespaceNs(this ISymbol? symbol)
                               {
                                   return IsExactlyNamespaceNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> is <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   int depth = 0;
                                   for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace) depth++;
                                   if (depth < 1) return false;
                                   for (int i = 0; i < depth - 1; i++) ns = ns!.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return true;
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is exactly <c>System</c>.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> equals <c>System</c>.</returns>
                               public static bool IsExactlyNamespaceNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   if (!ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;
                                   return ns != null && ns.IsGlobalNamespace;
                               }
                           
                           }
                           """, outputInt, SyntaxHelper.ComparisonOptions.None);
    }

    [Fact]
    public async Task RuntimeCorrectness()
    {
        var source = """
                     using Microsoft.CodeAnalysis;

                     [GenerateSymbolExtensions]
                     public static class Known
                     {
                         [SymbolNameExtension]
                         public const string ExceptionType = "System.Exception";
                         [NamespaceNameExtension]
                         public const string SystemNs = "System";
                     }
                     """;

        var (generated, diags) = await TestsHelper.RunHelperAsync(source);
        Assert.Empty(diags);
        SyntaxHelper.Equal("""
                           // <auto-generated/>
                           #nullable enable
                           using System;
                           using Microsoft.CodeAnalysis;
                           
                           namespace Microsoft.CodeAnalysis;
                           
                           public static class KnownExtensions
                           {
                               /// <summary>Returns <see langword="true"/> when <paramref name="symbol"/> is exactly <c>System.Exception</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is <c>System.Exception</c>.</returns>
                               public static bool IsNamedExactlyTypeExceptionType(this ISymbol? symbol)
                               {
                                   if (symbol is null) return false;
                                   if (!symbol.Name.Equals("Exception", StringComparison.Ordinal)) return false;
                                   if (symbol is not INamedTypeSymbol t0) return false;        if (t0.ContainingType is not null) return false;
                                   var ns = t0.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return ns != null && ns.IsGlobalNamespace;
                               }
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="symbol"/> is declared in <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceSystemNs(this ISymbol? symbol)
                               {
                                   return IsInNamespaceSystemNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when the namespace of <paramref name="symbol"/> is exactly <c>System</c>.</summary>
                               /// <param name="symbol">Symbol to check.</param>
                               /// <returns><see langword="true"/> if the namespace is exactly <c>System</c>.</returns>
                               public static bool IsExactlyInNamespaceSystemNs(this ISymbol? symbol)
                               {
                                   return IsExactlyNamespaceSystemNs(symbol as INamespaceSymbol ?? symbol?.ContainingNamespace);
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is <c>System</c> or nested within it.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> is <c>System</c> or a sub-namespace.</returns>
                               public static bool IsInNamespaceSystemNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   int depth = 0;
                                   for (var current = ns; current is not null && !current.IsGlobalNamespace; current = current.ContainingNamespace) depth++;
                                   if (depth < 1) return false;
                                   for (int i = 0; i < depth - 1; i++) ns = ns!.ContainingNamespace;
                                   if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;        return true;
                               }
                           
                               /// <summary>Returns <see langword="true"/> when <paramref name="ns"/> is exactly <c>System</c>.</summary>
                               /// <param name="ns">Namespace symbol to check.</param>
                               /// <returns><see langword="true"/> if <paramref name="ns"/> equals <c>System</c>.</returns>
                               public static bool IsExactlyNamespaceSystemNs(this INamespaceSymbol? ns)
                               {
                                   if (ns is null) return false;
                                   if (!ns.Name.Equals("System", StringComparison.Ordinal)) return false;
                                   ns = ns.ContainingNamespace;
                                   return ns != null && ns.IsGlobalNamespace;
                               }
                           
                           }
                           """, generated, SyntaxHelper.ComparisonOptions.None);

        var harness = """
                      using System;
                      using System.Linq;
                      using Microsoft.CodeAnalysis;
                      using Microsoft.CodeAnalysis.CSharp;

                      public static class RuntimeHarness
                      {
                          public static bool[] Run()
                          {
                              var refs = AppDomain.CurrentDomain.GetAssemblies()
                                  .Where(a => !a.IsDynamic && !string.IsNullOrEmpty(a.Location))
                                  .Select(a => MetadataReference.CreateFromFile(a.Location));
                              
                              var compilation = CSharpCompilation.Create("X", references: refs);
                              var exceptionType = compilation.GetTypeByMetadataName("System.Exception");
                              var intType = compilation.GetTypeByMetadataName("System.Int32");
                              var ns = exceptionType!.ContainingNamespace;
                              var global = ns.ContainingNamespace;
                              
                              return new bool[]{
                                  exceptionType!.IsNamedExactlyTypeExceptionType(),
                                  intType!.IsNamedExactlyTypeExceptionType(),
                                  exceptionType!.IsInNamespaceSystemNs(),
                                  global.IsInNamespaceSystemNs(),
                                  ns.IsExactlyNamespaceSystemNs(),
                                  global.IsExactlyNamespaceSystemNs()};
                          }
                      }
                      """;

        SyntaxTree globalUsings = CSharpSyntaxTree.ParseText(
            "global using MBW.Generators.GeneratorHelpers.Attributes;",
            new CSharpParseOptions(LanguageVersion.Latest));

        var syntaxTrees = new[]
        {
            globalUsings,
            CSharpSyntaxTree.ParseText(source),
            CSharpSyntaxTree.ParseText(generated!),
            CSharpSyntaxTree.ParseText(harness)
        };

        var refs = AppDomain.CurrentDomain.GetAssemblies()
            .Where(a => !a.IsDynamic && !string.IsNullOrEmpty(a.Location))
            .Select(a => MetadataReference.CreateFromFile(a.Location));

        var compilation = CSharpCompilation.Create("Runtime", syntaxTrees, refs,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        Assert.Empty(compilation.GetDiagnostics()
            .Where(s => s.Severity == DiagnosticSeverity.Error));

        using var ms = new MemoryStream();
        using var msPdb = new MemoryStream();
        var result = compilation.Emit(ms, msPdb);
        Assert.True(result.Success);

        var asm = Assembly.Load(ms.ToArray(), msPdb.ToArray());
        var run = asm.GetType("RuntimeHarness")!.GetMethod("Run")!;
        var arr = (bool[])run.Invoke(null, null)!;

        Assert.True(arr[0]);
        Assert.False(arr[1]);
        Assert.True(arr[2]);
        Assert.False(arr[3]);
        Assert.True(arr[4]);
        Assert.False(arr[5]);
    }
}