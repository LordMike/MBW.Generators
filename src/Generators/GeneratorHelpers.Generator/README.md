# MBW.Generators.GeneratorHelpers

## About
Provides allocation-free extension methods for Roslyn symbols based on predefined type and namespace strings. Annotate a type with constants representing canonical symbols and the generator emits helper methods to quickly compare symbols without allocations or `ToDisplayString` calls.

Useful when analyzing large code bases where repeated string construction would otherwise hurt performance.

## Quick Start
- Install the `MBW.Generators.GeneratorHelpers` package.
- Apply `[GenerateSymbolExtensions]` to a `class` or `struct` containing annotated `const string` fields.
- Override the generated extensions class name and namespace via the attribute’s `Name` and `Namespace` properties. Defaults to `<TypeName>Extensions` in `Microsoft.CodeAnalysis`.
- Per-field `MethodName` overrides customise the method suffix for `[SymbolNameExtension]` and `[NamespaceNameExtension]`.
- Fully qualified strings support the `global::` prefix, nested types using `+`, and generic metadata names like ``Dictionary`2``.
- The package includes both the attributes and the source generator.

## Example
```csharp
using MBW.Generators.GeneratorHelpers;
using MBW.Generators.GeneratorHelpers.Attributes;

// Control the generated type, Name and Namespace are optional - the default is 'Microsoft.CodeAnalysis'
[GenerateSymbolExtensions(Name = "KnownExtensions", Namespace = "My.Helpers")]
internal static class Known
{
    // Generate 
    [SymbolNameExtension(MethodName = "Exception")]
    public const string ExceptionType = "global::System.Exception";
}
```
Generates
```csharp
// <auto-generated/>
using System;
using Microsoft.CodeAnalysis;

namespace My.Helpers;

internal static class KnownExtensions
{
    public static bool IsNamedExactlyTypeException(this ISymbol? symbol)
    {
        if (symbol is null) return false;
        if (!symbol.Name.Equals("Exception", StringComparison.Ordinal)) return false;
        if (symbol is not INamedTypeSymbol t0) return false;
        if (t0.ContainingType is not null) return false;
        var ns = t0.ContainingNamespace;
        if (ns is null || !ns.Name.Equals("System", StringComparison.Ordinal)) return false;
        ns = ns.ContainingNamespace;
        return ns != null && ns.IsGlobalNamespace;
    }
}
```

## Features
- Generates allocation-free helpers for types and namespaces.
- Handles nested and generic types, including names with `global::` and multiple containing types.
- Provides `ISymbol` and `INamespaceSymbol` overloads for namespace checks.
- Supports custom extension class name/namespace and per-field method name overrides.
- Benchmarks show this approach is 10 times faster than performing a `ToDisplayString()` and then string equality

## Attributes
- **[GenerateSymbolExtensions]** – apply to a type to opt in. Controls generated class name and namespace.
- **[SymbolNameExtension]** – place on a `const string` field containing a fully qualified type name.
  - Generates:
    - `IsNamedExactlyTypeN(this ISymbol)` - tests if the symbol is exactly named N
- **[NamespaceNameExtension]** – place on a `const string` field containing a fully qualified namespace. 
  - Generates:
    - `IsInNamespaceN(this ISymbol)` - tests if the symbol is in the namespace N, or any namespace under N
    - `IsExactlyInNamespaceN(this ISymbol)` - tests if the symbol is exactly in the namespace N
    - `IsInNamespaceN(this INamespaceSymbol)` - tests if the namespace symbol is in the namespace N, or any namespace under N
    - `IsExactlyNamespaceN(this INamespaceSymbol)` - tests if the namespace symbol is exactly the namespace N

## More information
This project is provided as-is without support. Additional examples will be available in the [tests](../GeneratorHelpers.Tests).
